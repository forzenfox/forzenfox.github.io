{"randomArticles":[{"articleTitle":"JVM 学习笔记 - 垃圾回收器","articleAbstractText":"垃圾回收器的分类 按线程数分   串行垃圾回收器  适用于单 CPU 或者较小内存的硬件平台 在 Client 模式下的默认回收器    并行垃圾回收器  适用于多 CPU 同时执行垃圾回收，提升应用吞吐量    按工作模式分   并发式垃圾回收器  回收线程与应用程序交替工作，尽可能减少应用程序的停顿时间    独占式垃圾回收器 - STW  一旦运行，暂停用户线程，直到垃圾回收过程完全结束    按碎片处理方式分   压缩式垃圾回收器  在回收完成之后，对存活对象进行压缩整理，消除内存碎片 对象空间分配方式：指针碰撞    非压缩式垃圾回收器  无压缩整理过程 对象空间分配方式：空闲列表    按工作的内存区间分  年轻代垃圾回收器  Serial ParNew Parallel Scavenge   老年代垃圾回收器  Serial Old Parallel Old CMS   整堆垃圾回收期  G1     评估 GC 的性能指标   吞吐量：用户线程运行时间占总运行时间的比例 吞吐量 = 用户线程运行时间 / 用户线程运行时间 + 垃圾回收线程运行时间   暂停时间：执行垃圾....","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139215959.html","articleImg1URL":"https://b3logfile.com/bing/20210218.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"JVM 学习笔记 - 对象实例化","articleAbstractText":"对象实例化的方式   new 关键字  new Object();    反射机制   java.lang.Class#newInstance：只能调用 public 的空参构造器 java.lang.reflect.Constructor#newInstance：可以调用任何权限的空参、带参构造器     实现 Cloneable 接口，调用 clone() 复制对象（浅复制）   反序列化   第三方库 Objenesis   创建对象的步骤 加载对象对应的类 判断 new 指令的参数能否在 Metaspace 常量池中定位到一个类的符号引用，并且检查其类元信息是否存在（类是否被类加载器加载）   有类元信息则进行下一步   无，则在双亲委派模式下，使用当前类加载器进行加载  若找不到 .class 文件，则抛出异常 ClassNotFoundException    为对象分配内存   处理并发安全问题  每个线程预先分配私有的 TLAB 采用 CAS 失败重试、区域加锁    计算空间大小   在堆中分配内存空间   内存规整，使用 指针碰撞  使用过的内存在一边，空间的内存在....","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139059973.html","articleImg1URL":"https://b3logfile.com/bing/20191220.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"SQL学习笔记 - sql执行过程","articleAbstractText":"SQL 执行过程 Oracle 中 SQL 是如何执行的 SQL在Oracle中的执行过程：   共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。包括了库缓存和数据字典缓存区。    库缓存：主要缓存SQL语句和执行计划。 数据字典缓冲区：缓存Oracle中的对象定义，例如：表、视图、索引等对象。    共享池检查：Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。   在共享池中，Oracle会对SQL语句进行hash运算，根据hash值在库缓存中查找，命中则直接执行（软解析），未命中则创建解析树进行解析，生成执行计划，进入\u201c优化器\u201d(硬解析)。  Mysql 中的 SQL 是如何执行的 SQL 在Mysql中的执行过程：  Mysql由三层构成：  连接层：客户端和服务器端建立连接，客户端发送SQL到服务器端。 SQL层：对SQL语句进行查询处理。 存储引擎层：负责数据的读取和存储。  SQL层的结构：   查询缓存： 缓存命中SQL则直接返回结果。Mysql8.0之后该功能废弃。 执行器：....","articleStatus":0,"articlePermalink":"/articles/2021/11/05/1636107625790.html","articleImg1URL":"https://b3logfile.com/bing/20180210.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"MySQL 学习笔记 - 锁","articleAbstractText":"锁的分类 按数据操作类型划分：读锁、写锁  读锁：共享锁（Shared Lock）S 锁 写锁：排他锁（Exclusive Lock）X 锁      X 锁 S 锁     X 锁 不兼容 不兼容   S 锁 不兼容 兼容    锁定读   对读取记录加 S 锁 1select ... lock in share mode; 2# 或者 3select ... for share; #（8.0新增语法）    对读取记录加 X 锁 1select ... for update;    Mysql 8.0 新特性 1select ... for share nowait; # 如果查询的行已经加锁，立即报错返回 2select ... fro share skip locked; # 如果查询的行已经加锁，只返回未锁定的行 3 4# for update （X 锁） 同上  写操作   delete  获取行记录的 X 锁，执行 delete mark 操作。    update   未修改键值，并且被更新列占用的存储空间大小未发生变化  获取行记录的 X 锁，执行更新操作    未修....","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685968168813.html","articleImg1URL":"https://b3logfile.com/bing/20210221.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"}]}