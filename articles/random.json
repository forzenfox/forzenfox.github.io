{"randomArticles":[{"articleTitle":"MySQL 学习笔记 - 事务","articleAbstractText":"事务的常见分类  扁平事务 带有保存点的扁平事务 链事务 嵌套事务 分布式事务  InnoDB 事务 通过 锁机制 保证事务的隔离性 通过事务日志保证原子性、一致性、持久性(Durability)   重做日志 (redo log)  提供再写入操作，恢复提交事务修改的页操作，保证事务持久性    回滚日志 (undo log)  回滚行记录到特定版本，保证事务的原子性、一致性    事务状态  事务的启动方式 显示启动事务  begin/start transaction; 开启事务 commit;/rollback; 提交/回滚事务 commit work and chain；提交事务并自动启动下一个事务。  被动启动事务  set autocommit = 0; （关掉事务自动提交） 通过执行 SQL 语句启动事务 commit;/rollback;/断开连接 （提交/回滚事务）  隐式提交数据的情况   数据定义语句（DDL） 1begin; 2select ... 3update ... 4... 5 6create table ... # 隐式提交前面的语句    隐式使用....","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685968052392.html","articleImg1URL":"https://b3logfile.com/bing/20181018.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"MySQL 学习笔记 - MVCC","articleAbstractText":"相关概念 多版本并发控制(Multiversion Concurrency Control) MVCC，多版本并发控制。通过数据行的多个版本管理来实现数据库的 并发控制。使用乐观锁保证 InnoDB 的事务隔离级别下的 一致性读。 快照读 快照读又叫一致性读，读取的是快照数据。不加锁的简单 select 语句都属于快照读  串行化 隔离级别下 快照读 会退化为当前读 （串行化之后，默认读的都是最新数据）  当前读 当前读读取的是记录的最新版本，读取时话要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。 加锁的 select，或者对数据进行增删改都会进行当前读 1select * from student lock in share mode; # S 锁 2select * from student for update; # X 锁 3insert into student values ... ; # X 锁 4update student set ... ; # X 锁 5delete from student where ... ; # X 锁  MVCC 的实现原理....","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685968433040.html","articleImg1URL":"https://b3logfile.com/bing/20180210.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"JVM 学习笔记 - 对象实例化","articleAbstractText":"对象实例化的方式   new 关键字  new Object();    反射机制   java.lang.Class#newInstance：只能调用 public 的空参构造器 java.lang.reflect.Constructor#newInstance：可以调用任何权限的空参、带参构造器     实现 Cloneable 接口，调用 clone() 复制对象（浅复制）   反序列化   第三方库 Objenesis   创建对象的步骤 加载对象对应的类 判断 new 指令的参数能否在 Metaspace 常量池中定位到一个类的符号引用，并且检查其类元信息是否存在（类是否被类加载器加载）   有类元信息则进行下一步   无，则在双亲委派模式下，使用当前类加载器进行加载  若找不到 .class 文件，则抛出异常 ClassNotFoundException    为对象分配内存   处理并发安全问题  每个线程预先分配私有的 TLAB 采用 CAS 失败重试、区域加锁    计算空间大小   在堆中分配内存空间   内存规整，使用 指针碰撞  使用过的内存在一边，空间的内存在....","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139059973.html","articleImg1URL":"https://b3logfile.com/bing/20191220.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"JVM 学习笔记 - 堆","articleAbstractText":"堆 - Heap   每一个 JVM 实例只存在一个堆空间，堆也是 Java 内存管理的核心区域   Java 堆在 JVM 启动时创建，其大小也就确定了。 1-Xmx16g # 最大堆内存 16G = -XX:MaxHeapSize 2-Xms8g # 起始堆内存 8G = -XX:InitialHeapSize 3-XX:+PrintGCDetails # 打印GC的详细信息    一般会把 -Xms 和 -Xmx 的值配置相同的值，为了在垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能   默认大小  -Xms = 物理内存 / 64 -Xmx = 物理内存 / 4      Java 堆空间物理上可以不连续，逻辑上必须连续。   所有线程共享 Java 堆空间，但是堆中有线程私有得缓冲区（TLAB - Thread Local Allocation Buffer）   规范：所有得对象实例和数据都应当在运行时分配在堆上。  实际使用中，\u201c几乎\u201d所有的对象实例都在堆上分配    栈得栈帧中保存引用，引用指向对象或数据在堆中得位置。   方法结束后，堆中得对象不会....","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686138963923.html","articleImg1URL":"https://b3logfile.com/bing/20210114.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"MySQL 学习笔记 - 性能分析","articleAbstractText":"系统性能参数 1SHOW [GLOBAL|SESSION] STATUS LIKE '{性能参数}';   统计最近一次 SQL 查询成本 1show status like 'last_query_cost';  定位执行慢的 SQL: 慢查询日志 执行慢的 SQL : 运行时间超过 long_query_time 值的 SQL。long_query_time 默认值为 10(秒)。 开启慢查询日志 非调优需要，不建议开启慢查询日志 查询慢查询日志是否打开 1show variables like '%slow_query_log';  打开慢查询日志 1set global slow_query_log = on;  查询慢查询日志文件地址 1show variables like '%slow_query_log_file';  修改 long_query_time 阈值 查询 long_query_time 阈值 1show variables like '%long_query_time';  修改 long_query_time 阈值 1set global long_qu....","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685968215798.html","articleImg1URL":"https://b3logfile.com/bing/20180309.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"}]}