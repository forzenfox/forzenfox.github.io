{"relevantArticles":[{"articleTitle":"JVM 学习笔记 - 垃圾回收","articleAbstractText":"基本概念 什么是垃圾（Garbage） 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。 为什么需要 GC  不进行 GC，内存迟早会被消耗完 GC 的过程中，会进行碎片整理 没有 GC 无法保证应用程序的正常进行  Java 自动内存管理 优点：  降低内存泄漏和内存溢出的风险 使得开发人员更专心地专注于业务开发  缺点：  弱化开发人员在程序出现内存溢出时定位问题和解决问题的能力 对 JVM 进行必要的监控和调节  GC 作用的区域 GC 主要作用于 Java 堆和方法区（永久代/元空间）  频繁收集新生代 较少收集老年代 基本不懂永久代/元空间  System.gc() 的理解  显示触发 Full GC 无法保证 GC 的执行时间  内存溢出  Java 虚拟机堆内存设置不够 代码中创建大量大对象且长时间不能被垃圾收集器收集 抛出异常之前，通常会触发 GC 有些场景不会触发 GC：分配一个超大对象，超出了堆内存的最大值，会直接抛出异常  内存泄漏 严格上的定义：有对象不会被程序用到了，但是 GC 又不能回收他们的情况，叫内存泄漏 宽泛上的定义：对象生命....","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139190355.html","articleImg1URL":"https://b3logfile.com/bing/20210416.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"MySQL 学习笔记 - MVCC","articleAbstractText":"相关概念 多版本并发控制(Multiversion Concurrency Control) MVCC，多版本并发控制。通过数据行的多个版本管理来实现数据库的 并发控制。使用乐观锁保证 InnoDB 的事务隔离级别下的 一致性读。 快照读 快照读又叫一致性读，读取的是快照数据。不加锁的简单 select 语句都属于快照读  串行化 隔离级别下 快照读 会退化为当前读 （串行化之后，默认读的都是最新数据）  当前读 当前读读取的是记录的最新版本，读取时话要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。 加锁的 select，或者对数据进行增删改都会进行当前读 1select * from student lock in share mode; # S 锁 2select * from student for update; # X 锁 3insert into student values ... ; # X 锁 4update student set ... ; # X 锁 5delete from student where ... ; # X 锁  MVCC 的实现原理....","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685968433040.html","articleImg1URL":"https://b3logfile.com/bing/20180210.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"JVM 学习笔记 - 垃圾回收器","articleAbstractText":"垃圾回收器的分类 按线程数分   串行垃圾回收器  适用于单 CPU 或者较小内存的硬件平台 在 Client 模式下的默认回收器    并行垃圾回收器  适用于多 CPU 同时执行垃圾回收，提升应用吞吐量    按工作模式分   并发式垃圾回收器  回收线程与应用程序交替工作，尽可能减少应用程序的停顿时间    独占式垃圾回收器 - STW  一旦运行，暂停用户线程，直到垃圾回收过程完全结束    按碎片处理方式分   压缩式垃圾回收器  在回收完成之后，对存活对象进行压缩整理，消除内存碎片 对象空间分配方式：指针碰撞    非压缩式垃圾回收器  无压缩整理过程 对象空间分配方式：空闲列表    按工作的内存区间分  年轻代垃圾回收器  Serial ParNew Parallel Scavenge   老年代垃圾回收器  Serial Old Parallel Old CMS   整堆垃圾回收期  G1     评估 GC 的性能指标   吞吐量：用户线程运行时间占总运行时间的比例 吞吐量 = 用户线程运行时间 / 用户线程运行时间 + 垃圾回收线程运行时间   暂停时间：执行垃圾....","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139215959.html","articleImg1URL":"https://b3logfile.com/bing/20210218.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"MySQL 学习笔记 - InnoDB 的存储结构","articleAbstractText":"页 按类型划分  数据页 系统页 Undo 页 事务数据页  页结构   默认大小 16KB     区  尽量把 随机磁盘读取 -&gt; 顺序磁盘读取，提高范围查询时的性能  一个区 = 64 个页 (16 KB * 64 = 1 MB) 段  段是一个逻辑概念，由若干个零散的页面 + 一些完整的区组成   叶子节点段 非叶子节点段 数据段 索引段 回滚段  碎片区  直属表空间，碎片区中的页可用于不同的目的  表空间 系统表空间 独立表空间","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685968363446.html","articleImg1URL":"https://b3logfile.com/bing/20180827.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"MySQL 学习笔记 - 锁","articleAbstractText":"锁的分类 按数据操作类型划分：读锁、写锁  读锁：共享锁（Shared Lock）S 锁 写锁：排他锁（Exclusive Lock）X 锁      X 锁 S 锁     X 锁 不兼容 不兼容   S 锁 不兼容 兼容    锁定读   对读取记录加 S 锁 1select ... lock in share mode; 2# 或者 3select ... for share; #（8.0新增语法）    对读取记录加 X 锁 1select ... for update;    Mysql 8.0 新特性 1select ... for share nowait; # 如果查询的行已经加锁，立即报错返回 2select ... fro share skip locked; # 如果查询的行已经加锁，只返回未锁定的行 3 4# for update （X 锁） 同上  写操作   delete  获取行记录的 X 锁，执行 delete mark 操作。    update   未修改键值，并且被更新列占用的存储空间大小未发生变化  获取行记录的 X 锁，执行更新操作    未修....","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685968168813.html","articleImg1URL":"https://b3logfile.com/bing/20210221.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"}]}