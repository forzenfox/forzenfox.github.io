{"relevantArticles":[{"articleTitle":"Java 8 - CompletableFuture","articleAbstractText":"构建 CompletableFuture 直接返回计算结果 CompletableFuture.completedFuture 是一个静态辅助方法，用来返回一个已经计算好的 CompletableFuture。 1public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value) { 2 return new CompletableFuture&lt;U&gt;((value == null) ? NIL : value); 3}  示例代码： 1 /** 2 * 构建一个直接返回结果结果的 CompletableFuture 3 */ 4 @Test 5 public void test_create_completableFuture() { 6 CompletableFuture&lt;String&gt; strFuture = CompletableFuture.completedFuture(\"我是字符串\"); 7 System.out.println(\"strFuture 计算结果：\" +....","articleStatus":0,"articlePermalink":"/articles/2022/04/26/1650947125974.html","articleImg1URL":"https://b3logfile.com/bing/20180105.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"Spring Framework 学习笔记 - Spring 应用上下文生命周期","articleAbstractText":"Spring 应用上下文启动准备阶段 AbstractApplicationContext#prepareRefresh() 方法  启动时间 - startupDate **状态标识 - closed(false)、active(true) ** 初始化 PropertySources - initPropertySources()  默认实现为空：org.springframework.context.support.AbstractApplicationContext#initPropertySources   检验 Environment 中必须属性  ConfigurablePropertyResolver#setRequiredProperties   初始化事件监听器集合 初始化早期 Spring 事件集合  BeanFactory 创建阶段 AbstractApplicationContext#obtainFreshBeanFactory() 方法   刷新 Spring 应用上下文底层 BeanFactory  org.springframework.context.....","articleStatus":0,"articlePermalink":"/articles/2022/04/02/1648886248605.html","articleImg1URL":"https://b3logfile.com/bing/20201128.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"java 并发编程学习笔记","articleAbstractText":"java 并发编程学习笔记 进程和线程 进程  应用程序在内存中分配的空间，也就是正在运行的程序 各个进程互不干扰  线程  一个进程可以包含多个线程,每个线程单独负责一个子任务  java中的线程：   线程的优先级范围：0-10 优先级不能决定线程的执行顺序，只是给操作系统的建议，实际的执行顺序由操作系统的调度算法决定   为什么使用多线程实现并发,不使用多进程   进程重量级,开销比线程大 线程间通信容易,进程间通信困难   进程和线程的区别  本质区别: 是否独占内存地址空间和其他的系统资源 进程独占内存地址空间和系统资源,因此:  各个进程间数据隔离,数据共享困难但是同步简单. 创建/销毁进程开销大: 保存寄存器和栈信息,并且需要资源的分配和回收以及页调度. 独占内存,单个进程崩溃不影响其他进程,可靠性高  线程共享所属进程的内存地址空间和资源,因此:  各个线程间数据共享,数据共享容易但是同步困难. 创建/销毁线程开销小:保存寄存器和栈信息 共享内存和资源,单个线程崩溃可能会影响所属进程的稳定性,可靠性差   线程组   每个Thread必然存在于一个ThreadGroup....","articleStatus":0,"articlePermalink":"/articles/2022/03/13/1647154631868.html","articleImg1URL":"https://b3logfile.com/bing/20201024.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"TDD简述","articleAbstractText":"传统的开发流程 方案设计 -&gt; 代码实现 -&gt; 单元测试 -&gt; 问题修改 -&gt; 集成测试 -&gt; 问题修改 一般的认知:  设计先于实现,程序设计是很重要的，如果不做设计就开写，结果就是产生一坨垃圾！所以不要急着去写代码，写做好设计，理清思路后再动手！ 代码只要写的漂亮就行了。代码写得漂亮了，看代码就全懂了，文档的什么都是垃圾 代码写得好，可读性强，造成问题的概率就会低  什么是TDD 维基百科的解释:  测试驱动开发（英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于20世纪90年代。 测试驱动开发是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上重构的帽子，在测试的保护下，通过去除冗余的代码，提高代码质量。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。  TDD具体实施过程，可以看作两个层次 :  在代码层次，在编码之前写测试脚本，可以称为单元测试....","articleStatus":0,"articlePermalink":"/articles/2021/11/05/1636121282332.html","articleImg1URL":"https://b3logfile.com/bing/20171118.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"}]}