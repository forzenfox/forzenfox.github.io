{"relevantArticles":[{"articleTitle":"JVM 学习笔记 - 垃圾回收器","articleAbstractText":"垃圾回收器的分类 按线程数分   串行垃圾回收器  适用于单 CPU 或者较小内存的硬件平台 在 Client 模式下的默认回收器    并行垃圾回收器  适用于多 CPU 同时执行垃圾回收，提升应用吞吐量    按工作模式分   并发式垃圾回收器  回收线程与应用程序交替工作，尽可能减少应用程序的停顿时间    独占式垃圾回收器 - STW  一旦运行，暂停用户线程，直到垃圾回收过程完全结束    按碎片处理方式分   压缩式垃圾回收器  在回收完成之后，对存活对象进行压缩整理，消除内存碎片 对象空间分配方式：指针碰撞    非压缩式垃圾回收器  无压缩整理过程 对象空间分配方式：空闲列表    按工作的内存区间分  年轻代垃圾回收器  Serial ParNew Parallel Scavenge   老年代垃圾回收器  Serial Old Parallel Old CMS   整堆垃圾回收期  G1     评估 GC 的性能指标   吞吐量：用户线程运行时间占总运行时间的比例 吞吐量 = 用户线程运行时间 / 用户线程运行时间 + 垃圾回收线程运行时间   暂停时间：执行垃圾....","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139215959.html","articleImg1URL":"https://b3logfile.com/bing/20210218.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"Spring Framework 学习笔记 - IoC 依赖来源","articleAbstractText":"依赖查找的来源 查找来源  Spring 內建 BeanDefintion  Spring 內建单例对象  依赖注入的来源 注入来源  Spring 容器管理和游离对象(Resolvable Dependency)  Spring BeanDefinition 作为依赖   元数据  BeanDefinition 存储元信息    注册  BeanDefinitionRegistry#registerBeanDefinition    类型  延迟和非延迟    顺序  Bean 生命周期顺序按照注册顺序 1// Still in startup registration phase 2this.beanDefinitionMap.put(beanName, beanDefinition); 3this.beanDefinitionNames.add(beanName);  源码中,通过 Map 结构保证唯一性, List 结构保证有序性    单例对象作为依赖来源   来源  外部普通 Java 对象 (不一定是 POJO )    注册  SingletonBeanRegistry....","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685969400518.html","articleImg1URL":"https://b3logfile.com/bing/20190913.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"Spring Framework 学习笔记 - 注解","articleAbstractText":"Spring 核心注解场景分类 Spring 模式注解    Spring 注解 场景说明 起始版本     @Repository 数据仓储模式注解 2.0   @Component 通用组件模式注解 2.5   @Service 服务模式注解 2.5   @Controller Web 控制器模式注解 2.5   @Configuration 配置类模式注解 3.0    装配注解    Spring 注解 场景说明 起始版本     @ImportResource 替换 XML 元素 2.5   @Import 导入 Configuration 类 2.5   @ComponentScan 扫描指定 package 下标注 Spring 模式注解的类 3.1     @ComponentScan 默认扫描 当前类所在的包 源码分析如下：ComponentScanAnnotationParser.parse (line:123) 1public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentS....","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685969491723.html","articleImg1URL":"https://b3logfile.com/bing/20190913.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"JVM 学习笔记 - 垃圾回收","articleAbstractText":"基本概念 什么是垃圾（Garbage） 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。 为什么需要 GC  不进行 GC，内存迟早会被消耗完 GC 的过程中，会进行碎片整理 没有 GC 无法保证应用程序的正常进行  Java 自动内存管理 优点：  降低内存泄漏和内存溢出的风险 使得开发人员更专心地专注于业务开发  缺点：  弱化开发人员在程序出现内存溢出时定位问题和解决问题的能力 对 JVM 进行必要的监控和调节  GC 作用的区域 GC 主要作用于 Java 堆和方法区（永久代/元空间）  频繁收集新生代 较少收集老年代 基本不懂永久代/元空间  System.gc() 的理解  显示触发 Full GC 无法保证 GC 的执行时间  内存溢出  Java 虚拟机堆内存设置不够 代码中创建大量大对象且长时间不能被垃圾收集器收集 抛出异常之前，通常会触发 GC 有些场景不会触发 GC：分配一个超大对象，超出了堆内存的最大值，会直接抛出异常  内存泄漏 严格上的定义：有对象不会被程序用到了，但是 GC 又不能回收他们的情况，叫内存泄漏 宽泛上的定义：对象生命....","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139190355.html","articleImg1URL":"https://b3logfile.com/bing/20210416.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"JVM 学习笔记 - 直接内存","articleAbstractText":"概述   不是虚拟机运行时数据区的一部分，也不是 《Java 虚拟机规范》 中定义的内存区域。   直接内存是在 Java 堆外的、直接向系统申请的内存区间。  来源于 NIO ，通过 DirectByteBuffer 操作本地内存    直接内存的访问速度优于 Java 堆。（读写性能高）     不受最大堆内存参数（-Xmx）的影响，但是 Java 堆 + 直接内存 受限于操作系统能给出的最大内存    也会出现 OOM 1java.lang.OutOfMemoryError: Direct buffer memory    MaxDirectMemorySize 设置直接内存大小，不设置时默认与 \u2014Xmx 的值相同 1-XX:MaxDirectMemorySize=20m       缺点：  分配收回成本高 不受 JVM 内存回收管理  Java 进程占用的内存 = Java 堆 + 本地内存","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139087173.html","articleImg1URL":"https://b3logfile.com/bing/20200325.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"}]}