{"relevantArticles":[{"articleTitle":"Flyway - 数据库版本控制工具","articleAbstractText":"简介 一个能对数据库变更做版本控制的工具 Flyway官方文档 为什么要使用Flyway 实际的项目开发中,数据库的变更也需要版本控制,以便解决如下问题:   写的sql忘了是否在所有环境都执行过了,需要一个个切换环境数据库去确认 sql脚本修改过忘记归档,导致执行遗漏,测试环境出现问题甚至生产环境出现问题 每次上线 需要人为的执行Sql脚本,稳定性不可控.   Flyway运作方式 官方文档 Flyway命令 Migrate 官方描述:  Migrates the schema to the latest version. Flyway will create the schema history table automatically if it doesn\u2019t exist.  迁移指定的数据库schema到最新的版本.如果没有初始化过,会新建 flyway_schema_history 表.  eg : 最新的版本为202104290010,数据库的版本为202104290005 Migrate命令会依次执行 202104290005-&gt;202104290010的所有版本 ....","articleStatus":0,"articlePermalink":"/articles/2021/11/05/1636123283142.html","articleImg1URL":"https://b3logfile.com/bing/20171118.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"SQL - 索引","articleAbstractText":"索引类型 按功能逻辑划分   普通索引  无数据约束的基础索引    唯一索引  普通索引 + 数据唯一性约束    主键索引  普通索引 + 数据唯一性约束 + 不为空约束 一张表最多有一个    全文索引   按物理实现方式划分   聚集索引  聚集索引指表中的数据行按索引的排序方式进行物理存储.  索引必须是唯一索引 叶子节点存储的是整行数据     非聚集索引 (二级索引/辅助索引)  数据库中有单独的存储空间存放非聚集索引,这些索引按顺序存放,其叶子节点存放数据所在的位置 根据二级索引查询数据:先找到索引,然后找到索引对应的位置取出数据.    按字段个数划分   单一索引  索引列为一列 CREATE INDEX index_name ON table_name (column_name);     联合索引  多个列组合在一起创建的索引 CREATE INDEX union_index_name ON table_name (column_01_name,column_02_name);     如何使用索引 什么时候需要索引   使用索引对字段进行约束  对主键或者唯一....","articleStatus":0,"articlePermalink":"/articles/2022/03/13/1647154745757.html","articleImg1URL":"https://b3logfile.com/bing/20181018.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"SQL - 事务","articleAbstractText":"事务处理事务的特性 (ACID)事务并发处理可能产生的问题事务的隔离级别 事务处理 事务的特性 (ACID)  A (Atomicity),原子性.把一个事务当做不可分割的整体. C (Consistency),一致性.事务提交或者回滚后,数据的完整性约束不被破坏. I (Isolation),隔离性.事务之间彼此独立,不受到其他事务的执行影响. D (Durability),持久性.事务提交后的数据是持久性的.通过数据库日志可恢复的.  事务并发处理可能产生的问题   脏读 事务 B 读到的事务 A 未提交的修改内容 事务 A: 1begin; 2insert into heros_temp values(1,'金克斯');  事务 B: 1select * from heros_temp;    不可重复读 事务 A 两次读取同一条数据,获取的内容不一样. 事务 A: 1begin; 2-- 执行时间 2021-11-22 10:00:00 3select * from heros_temp where id = 1; 4-- 结果: 金克斯 5-- 执行时间 2021-11-22....","articleStatus":0,"articlePermalink":"/articles/2022/03/13/1647154841949.html","articleImg1URL":"https://b3logfile.com/bing/20201218.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"Spring Framework 学习笔记 - Spring 应用上下文生命周期","articleAbstractText":"Spring 应用上下文启动准备阶段 AbstractApplicationContext#prepareRefresh() 方法  启动时间 - startupDate **状态标识 - closed(false)、active(true) ** 初始化 PropertySources - initPropertySources()  默认实现为空：org.springframework.context.support.AbstractApplicationContext#initPropertySources   检验 Environment 中必须属性  ConfigurablePropertyResolver#setRequiredProperties   初始化事件监听器集合 初始化早期 Spring 事件集合  BeanFactory 创建阶段 AbstractApplicationContext#obtainFreshBeanFactory() 方法   刷新 Spring 应用上下文底层 BeanFactory  org.springframework.context.....","articleStatus":0,"articlePermalink":"/articles/2022/04/02/1648886248605.html","articleImg1URL":"https://b3logfile.com/bing/20201128.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"java 并发编程学习笔记","articleAbstractText":"java 并发编程学习笔记 进程和线程 进程  应用程序在内存中分配的空间，也就是正在运行的程序 各个进程互不干扰  线程  一个进程可以包含多个线程,每个线程单独负责一个子任务  java中的线程：   线程的优先级范围：0-10 优先级不能决定线程的执行顺序，只是给操作系统的建议，实际的执行顺序由操作系统的调度算法决定   为什么使用多线程实现并发,不使用多进程   进程重量级,开销比线程大 线程间通信容易,进程间通信困难   进程和线程的区别  本质区别: 是否独占内存地址空间和其他的系统资源 进程独占内存地址空间和系统资源,因此:  各个进程间数据隔离,数据共享困难但是同步简单. 创建/销毁进程开销大: 保存寄存器和栈信息,并且需要资源的分配和回收以及页调度. 独占内存,单个进程崩溃不影响其他进程,可靠性高  线程共享所属进程的内存地址空间和资源,因此:  各个线程间数据共享,数据共享容易但是同步困难. 创建/销毁线程开销小:保存寄存器和栈信息 共享内存和资源,单个线程崩溃可能会影响所属进程的稳定性,可靠性差   线程组   每个Thread必然存在于一个ThreadGroup....","articleStatus":0,"articlePermalink":"/articles/2022/03/13/1647154631868.html","articleImg1URL":"https://b3logfile.com/bing/20201024.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"}]}