{"relevantArticles":[{"articleTitle":"JVM 学习笔记 - 垃圾回收器","articleAbstractText":"垃圾回收器的分类 按线程数分   串行垃圾回收器  适用于单 CPU 或者较小内存的硬件平台 在 Client 模式下的默认回收器    并行垃圾回收器  适用于多 CPU 同时执行垃圾回收，提升应用吞吐量    按工作模式分   并发式垃圾回收器  回收线程与应用程序交替工作，尽可能减少应用程序的停顿时间    独占式垃圾回收器 - STW  一旦运行，暂停用户线程，直到垃圾回收过程完全结束    按碎片处理方式分   压缩式垃圾回收器  在回收完成之后，对存活对象进行压缩整理，消除内存碎片 对象空间分配方式：指针碰撞    非压缩式垃圾回收器  无压缩整理过程 对象空间分配方式：空闲列表    按工作的内存区间分  年轻代垃圾回收器  Serial ParNew Parallel Scavenge   老年代垃圾回收器  Serial Old Parallel Old CMS   整堆垃圾回收期  G1     评估 GC 的性能指标   吞吐量：用户线程运行时间占总运行时间的比例 吞吐量 = 用户线程运行时间 / 用户线程运行时间 + 垃圾回收线程运行时间   暂停时间：执行垃圾....","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139215959.html","articleImg1URL":"https://b3logfile.com/bing/20210218.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"MySQL 学习笔记 - 性能分析","articleAbstractText":"系统性能参数 1SHOW [GLOBAL|SESSION] STATUS LIKE '{性能参数}';   统计最近一次 SQL 查询成本 1show status like 'last_query_cost';  定位执行慢的 SQL: 慢查询日志 执行慢的 SQL : 运行时间超过 long_query_time 值的 SQL。long_query_time 默认值为 10(秒)。 开启慢查询日志 非调优需要，不建议开启慢查询日志 查询慢查询日志是否打开 1show variables like '%slow_query_log';  打开慢查询日志 1set global slow_query_log = on;  查询慢查询日志文件地址 1show variables like '%slow_query_log_file';  修改 long_query_time 阈值 查询 long_query_time 阈值 1show variables like '%long_query_time';  修改 long_query_time 阈值 1set global long_qu....","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685968215798.html","articleImg1URL":"https://b3logfile.com/bing/20180309.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"JVM 学习笔记 - 执行引擎","articleAbstractText":"概述 执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地的机器指令  Java 编译和执行的过程 由于 JVM 同时存在解释器和即时编译器，所以 Java 是半编译半解释型语言   前端编译器 把 .java 文件编译成 .class 文件  Sun 的 javac - 全量编译 Eclipse JDT 的 ECJ - 增量式编译  解释器 - Interpreter 对字节码采用逐行解释的方式执行：将每条字节码命令 翻译 成本地机器语言指令，再执行。   字节码解释器  通过纯软件代码模拟字节码的执行,效率低下    模板解释器  将每一条字节码和一个模板函数相关联,模板函数中直接产生这条字节码执行时的机器码    即时编译器 - JIT（Just In Time Compiler） 虚拟机将字节码代码直接编译成与本地机器平台相关的机器语言 **即时编译的目的：**将整个函数体编译成机器码，每次函数执行时，只执行编译之后的机器码即可。   C1 编译器  Client 模式下的 JIT 编译器。 简单可靠的优化，耗时短    C2 编译器  Server 模式下的 JIT 编....","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139118278.html","articleImg1URL":"https://b3logfile.com/bing/20200325.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"MySQL 学习笔记 - 主从复制","articleAbstractText":"作用  读写分离  针对读多写少的需求，降低单机压力，同时减少锁表概率，从而实现更高的并发访问      数据备份 高可用  原理 Slave 从 Master 读取 binlog 实现数据同步","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685968286672.html","articleImg1URL":"https://b3logfile.com/bing/20180309.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"MySQL 学习笔记 - MVCC","articleAbstractText":"相关概念 多版本并发控制(Multiversion Concurrency Control) MVCC，多版本并发控制。通过数据行的多个版本管理来实现数据库的 并发控制。使用乐观锁保证 InnoDB 的事务隔离级别下的 一致性读。 快照读 快照读又叫一致性读，读取的是快照数据。不加锁的简单 select 语句都属于快照读  串行化 隔离级别下 快照读 会退化为当前读 （串行化之后，默认读的都是最新数据）  当前读 当前读读取的是记录的最新版本，读取时话要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。 加锁的 select，或者对数据进行增删改都会进行当前读 1select * from student lock in share mode; # S 锁 2select * from student for update; # X 锁 3insert into student values ... ; # X 锁 4update student set ... ; # X 锁 5delete from student where ... ; # X 锁  MVCC 的实现原理....","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685968433040.html","articleImg1URL":"https://b3logfile.com/bing/20180210.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"}]}