{"relevantArticles":[{"articleTitle":"JVM 学习笔记 - 垃圾回收","articleAbstractText":"基本概念 什么是垃圾（Garbage） 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。 为什么需要 GC  不进行 GC，内存迟早会被消耗完 GC 的过程中，会进行碎片整理 没有 GC 无法保证应用程序的正常进行  Java 自动内存管理 优点：  降低内存泄漏和内存溢出的风险 使得开发人员更专心地专注于业务开发  缺点：  弱化开发人员在程序出现内存溢出时定位问题和解决问题的能力 对 JVM 进行必要的监控和调节  GC 作用的区域 GC 主要作用于 Java 堆和方法区（永久代/元空间）  频繁收集新生代 较少收集老年代 基本不懂永久代/元空间  System.gc() 的理解  显示触发 Full GC 无法保证 GC 的执行时间  内存溢出  Java 虚拟机堆内存设置不够 代码中创建大量大对象且长时间不能被垃圾收集器收集 抛出异常之前，通常会触发 GC 有些场景不会触发 GC：分配一个超大对象，超出了堆内存的最大值，会直接抛出异常  内存泄漏 严格上的定义：有对象不会被程序用到了，但是 GC 又不能回收他们的情况，叫内存泄漏 宽泛上的定义：对象生命....","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139190355.html","articleImg1URL":"https://b3logfile.com/bing/20210416.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"JVM 学习笔记 - 直接内存","articleAbstractText":"概述   不是虚拟机运行时数据区的一部分，也不是 《Java 虚拟机规范》 中定义的内存区域。   直接内存是在 Java 堆外的、直接向系统申请的内存区间。  来源于 NIO ，通过 DirectByteBuffer 操作本地内存    直接内存的访问速度优于 Java 堆。（读写性能高）     不受最大堆内存参数（-Xmx）的影响，但是 Java 堆 + 直接内存 受限于操作系统能给出的最大内存    也会出现 OOM 1java.lang.OutOfMemoryError: Direct buffer memory    MaxDirectMemorySize 设置直接内存大小，不设置时默认与 \u2014Xmx 的值相同 1-XX:MaxDirectMemorySize=20m       缺点：  分配收回成本高 不受 JVM 内存回收管理  Java 进程占用的内存 = Java 堆 + 本地内存","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139087173.html","articleImg1URL":"https://b3logfile.com/bing/20200325.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"Spring Framework 学习笔记 - IoC 依赖注入","articleAbstractText":"依赖注入的模式和类型   自动绑定 (Autowiring)  自动绑定的限制和不足  Core Technologies (spring.io)  Setter 方法注入  构造器注入  字段注入  方法注入  接口回调注入   Aware 系列接口回调   自动模式    內建接口 说明     BeanFactoryAware 获取 IoC 容器 - BeanFactory   ApplicationContextAware 获取 Spring 应用上下文 - ApplicationContext 对象   EnvironmentAware 获取 Environment 对象   ResourceLoaderAware 获取资源加载器 对象 - ResourceLoad   BeanClassLoaderAware 获取加载当前 Bean Class 的 ClassLoader   BeanNameAware 获取当前 Bean 的名称   MessageSourceAware 获取 MessageSource 对象，用于 Spring 国际化   ApplicationEven....","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685969463102.html","articleImg1URL":"https://b3logfile.com/bing/20190913.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"JVM 学习笔记 - 执行引擎","articleAbstractText":"概述 执行引擎的任务就是将字节码指令解释/编译为对应平台上的本地的机器指令  Java 编译和执行的过程 由于 JVM 同时存在解释器和即时编译器，所以 Java 是半编译半解释型语言   前端编译器 把 .java 文件编译成 .class 文件  Sun 的 javac - 全量编译 Eclipse JDT 的 ECJ - 增量式编译  解释器 - Interpreter 对字节码采用逐行解释的方式执行：将每条字节码命令 翻译 成本地机器语言指令，再执行。   字节码解释器  通过纯软件代码模拟字节码的执行,效率低下    模板解释器  将每一条字节码和一个模板函数相关联,模板函数中直接产生这条字节码执行时的机器码    即时编译器 - JIT（Just In Time Compiler） 虚拟机将字节码代码直接编译成与本地机器平台相关的机器语言 **即时编译的目的：**将整个函数体编译成机器码，每次函数执行时，只执行编译之后的机器码即可。   C1 编译器  Client 模式下的 JIT 编译器。 简单可靠的优化，耗时短    C2 编译器  Server 模式下的 JIT 编....","articleStatus":0,"articlePermalink":"/articles/2023/06/07/1686139118278.html","articleImg1URL":"https://b3logfile.com/bing/20200325.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"},{"articleTitle":"Spring Framework 学习笔记 - IoC 依赖查找","articleAbstractText":"Java 原生依赖查找   单一类型依赖查找   JNDI  javax.naming.Context#lookup(javax.naming.Name)    JavaBean  java.beans.beancontext.BeanContext      集合类型依赖查找  java.beans.beancontext.BeanContextServices#getCurrentServiceSelectors    层次性依赖查找  java.beans.beancontext.BeanContext    Spring IoC 依赖查找 单一类型依赖查找 单一类型依赖查找接口：  org.springframework.beans.factory.BeanFactory    根据 Bean 名称查找  org.springframework.beans.factory.BeanFactory#getBean(java.lang.String) org.springframework.beans.factory.BeanFactory#getBean(java.lang.St....","articleStatus":0,"articlePermalink":"/articles/2023/06/05/1685969358725.html","articleImg1URL":"https://b3logfile.com/bing/20190913.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"}]}